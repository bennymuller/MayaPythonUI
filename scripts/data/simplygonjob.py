from time import gmtime, strftime
import maya.mel as mel
import texturecollection
import materialcollection
import objectcollection
reload (texturecollection)
reload (materialcollection)
reload (objectcollection)

from texturecollection import *
from materialcollection import *
from objectcollection import *

"""
Stores all the data that is generated during a Simplygon job.
"""
class SimplygonJob:
	def __init__(self):		
		self._directives = None
		self._time = strftime("%H:%M:%S", gmtime())
		self._textureCollection = None
		self._materialCollection = None
		self._objectCollection = None
	
	"""
	Returns the time this job was started as a string 
	"""
	@property
	def time(self):
		return self._time
		
	"""
	Returns the name of this job
	"""
	@property
	def	name(self):
		# Time will suffice as description for now
		return self.time
		
	"""
	Returns the directives that was used to run this job
	"""
	@property
	def directives(self):
		return self._directives

	"""
	Will start a Simplygon process with the specified directives
	@param directives: the settings to use during the process
	"""
	def runJob(self, directives):
		melCmd = "Simplygon -sf \""+directives.settingFile+"\" "
		if directives.batchMode:
			melCmd += "-b "
		#Check if the user weights are enabled, in that case send that along to Simplygon.
		if directives.useWeights:
			if directives.colorSet != None:
				melCmd += "-caw \""+directives.colorSet+"\" -wm "+ str(directives.weightMultiplier)
		self._directives = directives

		#Take a snapshot of the scene before the process starts
		self._textureCollection = TextureCollection()
		self._materialCollection = MaterialCollection()
		self._objectCollection = ObjectCollection()
		self._textureCollection.takeSnapShot()
		self._materialCollection.takeSnapShot()
		self._objectCollection.takeSnapShot()
	
		#Run the simplygon job
		result = mel.eval(melCmd)
		
		#Find out what Simplygon created
		self._textureCollection.calculateDiff()
		self._materialCollection.calculateDiff(self._textureCollection)
		self._objectCollection.calculateDiff(self._materialCollection)

			
	"""
	Returns the LOD's generated by this process. As a dictionary with lod index as key of object data lists.
	"""
	def getLODs(self):
		return self._objectCollection.getLODs()

	"""
	Generates a layer per LOD.
	"""	
	def makeLayers(self):
		lods = self._objectCollection.getLODs()
		for lod in lods:
			layer = cmds.createDisplayLayer(empty=True, n="LOD"+str(lod))
			cmds.editDisplayLayerMembers(layer, lods[lod].objectNames) 
	
	"""
	Cleans out duplicate materials and textures and reroutes objects and materials.
	"""	
	def pruneTexturesAndMaterials(self):
		self._materialCollection.rerouteMaterials()
		self._objectCollection.rerouteObjects()
		self._textureCollection.deleteDuplicates()
		self._materialCollection.deleteDuplicates()
		
	"""
	Breaks up the LODs in the X axis.
	"""	
	def splitLODs(self):
		self._objectCollection.splitLODs()

	"""
	Moves all textures generated by this job to the specified location.
	@param directory: the directory to move all textures to
	"""
	def moveTextures(self, directory):
		if directory == None or directory == "":
			raise RuntimeError("No directory specified to move textures to")

		self._textureCollection.moveTextures(directory)

	"""
	Not yet implemented. Should allow to rename objects, materials, textures by replacing parts of their names. 
	"""
	def rename(self, replaceString, newString):
		pass

	"""
	Cleans the data sets of any objects, materials or textures that have been removed from the scene.
	"""
	def removeInvalidAssets(self):
		self._objectCollection.removeInvalidAssets()
		self._textureCollection.removeInvalidAssets()
		self._materialCollection.removeInvalidAssets()
		
	"""
	Not yet implemented. Should return true if there is no assets left in this job.
	"""
	def isEmpty(self):	
		return False
		